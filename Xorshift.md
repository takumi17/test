# Xorshift

## 1.初めに

Xorshift乱数生成器(RNG)は, ビットシフトとXOR(排他的論理和)からなる処理で $2^{32}-1$ 個の $x$ , $2^{64}-1$ 個の $x, y$ , $2^{96}-1$ 個の $x, y ,z$ などの順序付けられた要素の集合(シーケンス)である. C言語では, 基本的な操作は, `y^(y<<a)` や `y^(y>>a)`と排他的論理和である. Xorshiftの操作の効果を示すためにランダムシード $x, y, z, w$ を使用して, 1回の呼び出しでわずか３つのXorshiftの操作を行い, $2^{128}-1$ 個のランダムな $32$ ビット整数を生成するcプロシージャ(関数)の基本部分である.
プロシージャは, Cプログラミング言語で記述されたプログラム内の特定の機能や手順を実行するためのコードブロックである. 通常, Cプロシージャは関数として実装される.

'''c
tmp = (x\^(x<<15)); x=y; y=z; z=w; return w=(w\^(w>>21))\^(tmp\^(tmp>>4));
'''

Xorshiftの操作は高速かつ秒間 $2$ 億回以上の速度で動作する.



## 2.理論

$m$ 個の要素 $(x_1, x_2, \ldots , x_m)$ からなるシードセット $Z$ を持ち, $Z$ 上の一対一の関数 $f()$ がある. 
$Z$ から一様かつランダムに $z$ が選択された場合, RNGはの出力は $f(z), f^2(z), f^3(z)$ などのシーケンスであり, ここで $f^2(z)$ は $f(f(z))$ を意味する.
$f$ は $Z$ 上で一対一なので, 乱数変数 $f(z)$ が $Z$ 上で一様であり, $f^2(z)$ も同様である. 実際, シーケンス $f(z), f^2(z), \ldots$ の各要素は $Z$ 上で一様に分布しているが, 独立ではない.

XorshiftRNGの場合, シードセット $Z$ はゼロベクトルを除く $1 \times n$ のバイナリベクトルの集合である. 通常 $n$ は $32, 64, 96$ などである. $Z$ 内のベクトル $\beta$ の要素は ${0, 1}$ にあるため, 構成要素の $32$ ビット部分を XOR することで実装できる. XorshiftRNGでは, $Z$ 上の逆関数が必要である. そのために非特異 (正則)な $n×n$ バイナリ行列 $T$ で特徴付けられるバイナリベクトル空間上の線形変換を使用する. もし $\beta$ が $Z$ から一様にランダムに選択(シード) なら、シーケンス $\beta T, \beta T^2, \beta T^3, \ldots$ の各要素も $Z$ 上で一様に分布しているため、$Z$ からの一様な要素である ID (identically distributed) (一様分布した) のシーケンスを持つが、それらはIID (independent identically distributed) (独立同分布) ではない. 

- ChatGPT
独立同分布（Independent and Identically Distributed、IID）とは, 統計学や確率論において, 複数の確率変数が互いに独立であり, かつ同じ確率分布に従うことを意味する.
同一分布性（identically distributed）は, 確率論や統計学において用いられる概念で, 複数の確率変数が同じ確率分布に従っていることを指す. つまり, 異なる確率変数が同じ確率分布を持つことを表す.


例えば, $1 \times 4$ のバイナリベクトル $x$ と, $4 \times 4$ の $１$ ビット左シフトバイナリ行列 $L_1$, $2$ ビット左シフトバイナリ行列 $L_2$ 以下のように表現する
$$
x = \begin{bmatrix}
0 \\
1 \\
1 \\
0 
\end{bmatrix}
L_1 = \begin{bmatrix}
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1\\
0 & 0 & 0 & 0
\end{bmatrix}
L_2 = \begin{bmatrix}
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0
\end{bmatrix}
$$


$$
L_{1}x = \begin{bmatrix}
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1\\
0 & 0 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
0 \\
1 \\
1 \\
0 
\end{bmatrix}
= \begin{bmatrix}
1 \\
1 \\
0 \\
0 
\end{bmatrix}
$$

$$
L_{1}(L_{1}x) = \begin{bmatrix}
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
1 \\
1 \\
0 \\
0 
\end{bmatrix}
= \begin{bmatrix}
1 \\
0 \\
0 \\
0 
\end{bmatrix}
= (L_1)^2 x
$$

$$
L_{2}x = \begin{bmatrix}
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
0 \\
1 \\
1 \\
0 
\end{bmatrix}
= \begin{bmatrix}
1 \\
0 \\
0 \\
0 
\end{bmatrix}
= (L_1)^2 x
$$


## 2.1 全ての非ゼロのバイナリベクトルを生成する行列T
定理: 正則な $n\times n$ のバイナリ行列 $T$ が, 任意の非ゼロの初期 $n\times n$ のバイナリベクトル $\beta$ に対して, $\beta T, \beta T^2, \beta T^3, \ldots$ の全ての可能な非ゼロの $n\times n$ のバイナリベクトルを生成するためには, $T$ の群の中で $T$ の次数が $2^{n}-1$ であることが必要かつ十分である.

証明
必要性: $\beta T, \beta T^2, \beta T^3, \ldots$ の周期が $k = 2^{n}-1$ である場合, 任意の $1\times n$ のバイナリベクトル $\beta$ に対して $\beta T^k = \beta$ が成り立つため, 行列 $T^{k} + I$ はゼロ行列でなければならず, $T^k = I$ となる. もし, $T^j = I$ $(j<k)$ である場合, $\beta T, \beta T^2, \beta T^3, \ldots$ の周期は $2^{n}-1$ より小さくなる.
十分性: $T$ の次数が $2^{n}-1$ である場合, 行列 $T, T^2, T^3, \ldots , T^k$ は正則で異なるものであり, $T$ の特性方程式とユークリッドのアルゴリズムを用いて, 次数が $n$ 未満の $T$ の多項式として表すことができる. 次数が $n$ 未満の $T$ の非ゼロ多項式が $k=2^{n}-1$ 個であるため, それらは異なる正則行列 $T, T^2, T^3, \ldots , T^k$ は何らかの順序でなければならない.
特に, $T$ の多項式が特異行列である場合, $T$ の特性多項式を通じてゼロ行列に帰着しなければならない. したがって, $\beta T, \beta T^2, \beta T^3, \ldots$ の周期が $k = 2^{n}-1$ でなければならず, 非ゼロの $\beta$ と $j<k$ に対して $\beta T^{j} = \beta$ が成り立つとき, $T^{j} + I$ が特異行列であることを意味する.

aaaaaaaaaaaa
aaaaaaaaaaa
aaaaaaaaa
aaaaaaa
aaaaaa
aaaaa
aaaa
aa
a
a
